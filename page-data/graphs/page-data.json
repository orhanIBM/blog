{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/graphs/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Orhan's Blog"}},"markdownRemark":{"id":"97e3012f-1241-51a0-a71d-1798ddf6ea56","excerpt":"This is the summary of graph algorithms course by Alvin Zablan @ Structy. I really like his teaching technique. He takes the time to explain things in detail…","html":"<p>This is the summary of graph algorithms course by Alvin Zablan @ <a href=\"https://www.structy.net/\">Structy</a>.</p>\n<p>I really like his teaching technique. He takes the time to explain things in detail. You can give it a free try at Structy too.</p>\n<p>This blog is mostly a blue-print / pseudocode to myself. Not exhaustive or aims to teach the reader about the details, but rather a note to myself.</p>\n<p>The graph algorithms begin with a search. Depth First versus Breath First.</p>\n<p>Note that these are Directed Acyclical Graphs (DAGs). More on that later…</p>\n<h3>Depth First Search</h3>\n<p>There are two ways to achieve the Depth First Search (DFS).</p>\n<p>First pattern is recursive (obviously) and second pattern is a stack based loop. But either way, the graph is represented with an object/hashmap/dict, where key represents the vertex and values are the edges to the vertices. An example is:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> graph <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    b<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">]</span>\n    c<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The recursive pattern pseudocode</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">depth_first</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">graph<span class=\"token punctuation\">,</span> vertex</span><span class=\"token punctuation\">)</span>  <span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// base case, execute and stop</span>\n    <span class=\"token comment\">// recursive case </span>\n    \n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>vertex<span class=\"token punctuation\">)</span> <span class=\"token comment\">//</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> neighbour <span class=\"token keyword\">of</span> graph<span class=\"token punctuation\">[</span>vertex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">depth_first</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">,</span> neighbour<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Loop pattern</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">cosnt <span class=\"token function-variable function\">depth_first</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">graph<span class=\"token punctuation\">,</span> starting_vertex</span><span class=\"token punctuation\">)</span>  <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// base case </span>\n    <span class=\"token comment\">// create a stack: const stack = [starting_vertex];</span>\n    <span class=\"token comment\">// as long as there are elements on the vertex, process them </span>\n    <span class=\"token comment\">// then add each neighbour of the current vertex into the stack</span>\n\n    <span class=\"token comment\">// i.e.</span>\n    <span class=\"token keyword\">const</span> stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>starting_vertex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> current_vertex <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> neighbour <span class=\"token keyword\">of</span> graph<span class=\"token punctuation\">[</span>current_vertex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>neighbour<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Breadth First Search</h3>\n<p>For Breadth First Search (BFS), instead of implementing a stack, where the last one added is processed first, this will be a queue, where first in is first out. And add the children of the current item on the queue, to the end of the line.</p>\n<p>The pattern is a single loop over a queue. There is not a recursive pattern here.</p>\n<p>Using the same graph object:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> graph <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    b<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">]</span>\n    c<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>BFS pseudo code for printing elements are:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">bread_first_search</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">graph<span class=\"token punctuation\">,</span> vertex</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// create a queue with the first item being the starting vertex</span>\n    <span class=\"token comment\">// then as long as there are items to process in the queue</span>\n    <span class=\"token comment\">// process it, and then add the children of the queue to the END of the queue </span>\n    <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>vertex<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> current_vertex <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// returns the first element from the queue, while removing it from the array;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>current_vertex<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> neighbour <span class=\"token keyword\">of</span> graph<span class=\"token punctuation\">[</span>current_vertex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>neighbour<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Undirected Graphs</h3>\n<p>Undirected graphs are same as DAGs but edges are both ways. Assume that there is a vertex m and vertex n, and these are connected it would be represented as</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// eges are represented as an array of arrays, because there can be other vertices that are connected in the list</span>\n<span class=\"token keyword\">const</span> edges <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token string\">'m'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'n'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> </code></pre></div>\n<p>Since we have the graph object as adjacency list, shown in the previous section, why not convert to it?</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//convert edges to adjacency list, while keeping both directions</span>\n<span class=\"token keyword\">const</span> graph <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    m <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'n'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    n <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'m'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>But this bring cyclicality issues</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// edges can be cyclical too</span>\n<span class=\"token comment\">// i points to j, which points to k but k can point back to i</span>\n<span class=\"token keyword\">const</span> edges <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">[</span><span class=\"token string\">'i'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'j'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">[</span><span class=\"token string\">'j'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'k'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">[</span><span class=\"token string\">'k'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'i'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>To avoid infinity loop above, the solution is to create a Set that tracks the vertices that we already visited.</p>","frontmatter":{"title":"Graphs","date":"December 21, 2021","description":"Graph algorithms by Alvin Zablan"}},"previous":{"fields":{"slug":"/about-me/"},"frontmatter":{"title":"All About Me"}},"next":{"fields":{"slug":"/loop-in-python/"},"frontmatter":{"title":"For Loop"}}},"pageContext":{"id":"97e3012f-1241-51a0-a71d-1798ddf6ea56","previousPostId":"77a71ec5-1913-5077-9824-399a5b5539e3","nextPostId":"8bbdf849-1152-5836-8e73-dda752888a2f"}},
    "staticQueryHashes": ["2841359383","3257411868"]}